/*  正整数s（简称为合数）的划分是把s分成若干个正整数（简称为零数或部分）之和，划分式中允许零数重复，且不考虑零数的次序
    对于k较小时进行观察归纳：
    k=2: 1+1; 2
    k=3: 1+1+1; 1+2; 3
    k=4: 1+1+1+1; 1+1+2; 1+3; 2+2; 4
    k=5: 1+1+1+1+1; 1+1+1+2; 1+1+3; 1+2+2; 1+4; 2+3; 5
    由以上看到，除了k=k这一特殊情况外，数k与数k-1有以下递推关系：
    (1) z在所有和数k-1的划分式前加"1"都是和数"k"的划分式
    (2) 和数k-1的划分式的前两个零数作比较，如果第一个零数x1小于第二个零数x2, 则把第1个零数加1后成为和数k的划分式
    第一套方案是建立三维数组a(k,j,i)为和数k的第j个划分式的第i个数，现简化成二维数组a(j,i):
    即用二维数组a(j,i)表示和数是k-1已有划分式，以此递推出k的划分式*/

#include<stdio.h>
void main()
{
    int s,i,j,k,t,u;
    static int a[1600][25];
    printf("Input s(s<=24):"); scanf("%d",&s);
    a[1][1]=1;a[1][2]=1;a[2][1]=2;u=2;
    for(k=3;k<=s;k++)
    {
        for(j=1;j<=u;j++)
        {
            i=k-1;
            for(t=i;t>=1;t--)
                a[j][t+1]=a[j][t];              //k-1的所有项向后移一位，然后前面添上1
            a[j][1]=1;
        }
        for(t=u,j=1;j<=u;j++)
            if(a[j][2]<a[j][3])                 //若k的第2项小于第3项，即k-1划分式第1项小于第2项
        {
            t++;                                //注意t的设置，即从u开始变化，每增加一个划分式t加1
            a[t][1]=a[j][2]+1;                  //第2项加1，并且将第一项的1去除
            i=3;
            while(a[j][i]>0)
            {
                a[t][i-1]=a[j][i];i++;
            }
        }
        t++;a[t][1]=k;                          //最后一个划分式为k=k
        u=t;
    }
    for(j=1;j<=u;j++)
    {
        printf("%3d: %d=%d",j,s,a[j][1]);
        i=2;
        while(a[j][i]>0)
        {
            printf("+%d",a[j][i]);i++;
        }
        printf("\n");
    }
}
